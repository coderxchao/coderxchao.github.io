import{_ as a,c as r,b as e,o as l}from"./app-3ObzEPbj.js";const i={};function n(o,t){return l(),r("div",null,t[0]||(t[0]=[e("p",null,[e("a",{href:"https://zhuanlan.zhihu.com/p/580956436?utm_id=0",target:"_blank",rel:"noopener noreferrer"},"面试必问之 JS 事件循环(Event Loop)，看这一篇足够")],-1),e("p",null,"JS 事件循环机制涉及到宏任务，微任务，JS 单线程执行，浏览器异步机制这些概念。",-1),e("ol",null,[e("li",null,"首先在开始解析执行 JS 代码的时候，JS 引擎线程会生成一个执行上下文栈，并创建一个全局执行上下文，压入执行栈底部，开始执行全局代码。碰到函数调用的话会创建一个函数执行上下文并压入执行栈，执行函数中的代码。"),e("li",null,"由于 JS 引擎线程执行 JS 代码是同步的，所以当 JS 引擎碰到异步代码例如 setTimeout 时，:: 浏览器:: 会单独开启一个线程来处理 setTimeout 的定时器操作，此时 JS 引擎继续执行后面的同步代码，当 setTimeout 定时完成后，浏览器会将定时器的回调函数放入一个宏任务队列。如果碰到像 Promise. Then 时，会将 then 中的回调函数放入一个微任务队列。"),e("li",null,"事件循环其实就是一个持续监控调用栈（执行上下文栈）和任务队列的过程。当 JS 引擎监控到调用栈为空时（即当前没有正在执行的 JS 代码，本轮循环的 JS 代码都执行完毕，执行上下文栈中只剩一个全局执行上下文），JS 引擎线程会先查看微任务队列中有没有需要执行的任务，如果有，则取出来放入调用栈执行，直到微任务队列中不再有任务时，才会再从宏任务队列中查看并取出宏任务队列中的任务来执行。这样一个持续监控调用栈并从任务队列中取出任务执行的过程就是事件循环。")],-1)]))}const c=a(i,[["render",n],["__file","index.html.vue"]]),s=JSON.parse('{"path":"/article/xymrd275/","title":"JS 事件循环机制","lang":"zh-CN","frontmatter":{"title":"JS 事件循环机制","createTime":"2024/11/07 14:39:25","permalink":"/article/xymrd275/","tags":["js高级","事件循环"]},"headers":[],"readingTime":{"minutes":1.66,"words":499},"git":{"createdTime":1730966370000,"updatedTime":1730966370000,"contributors":[{"name":"coderchao","email":"coderchao@foxmail.com","commits":1}]},"filePathRelative":"JavaScript进阶/JS 事件循环机制.md","categoryList":[{"id":"6c19ce","sort":10000,"name":"JavaScript进阶"}],"bulletin":false}');export{c as comp,s as data};
