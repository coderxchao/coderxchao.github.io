import{_ as l,c as e,a as n,o as c}from"./app-3ObzEPbj.js";const s={};function i(o,a){return c(),e("div",null,a[0]||(a[0]=[n('<blockquote><p>PS：如果想要更新一个已经安装的 node 包版本，可以通过 npm update &lt;package_name&gt; 来进行更新。此操作会实际更新 package-lock. Json 中的版本，但是不会更新 package. Json 中的版本。如果想两个文件中版本都更新到最新，则需要通过 npm install &lt;package_name&gt; 重新安装一次</p></blockquote><h2 id="有-package-lock-json-文件的情况" tabindex="-1"><a class="header-anchor" href="#有-package-lock-json-文件的情况"><span>有 package-lock. Json 文件的情况</span></a></h2><h3 id="_1-读取-package-lock-json-文件" tabindex="-1"><a class="header-anchor" href="#_1-读取-package-lock-json-文件"><span>1 . 读取 package-lock. Json 文件</span></a></h3><ul><li>Npm 首先读取 package-lock. Json 文件，获取上次安装的确切依赖项版本和依赖树结构。</li></ul><h3 id="_2-验证一致性" tabindex="-1"><a class="header-anchor" href="#_2-验证一致性"><span>2 . 验证一致性</span></a></h3><ul><li>Npm 检查 package. Json 文件中的依赖项版本范围是否与 package-lock. Json 文件中记录的确切版本一致。</li><li>如果一致，继续下一步；如果不一致，npm 会结合 package. Json 与 package-lock. Json 文件重新解析构建依赖树。</li></ul><h3 id="_3-从缓存中获取依赖项" tabindex="-1"><a class="header-anchor" href="#_3-从缓存中获取依赖项"><span>3 . 从缓存中获取依赖项</span></a></h3><ul><li>Npm 尝试从本地缓存中获取依赖树中确切版本的依赖项。</li><li>如果本地缓存中有这些包，直接从缓存中恢复；如果没有，则从 npm 注册表下载并保存到本地缓存。</li></ul><h3 id="_4-安装依赖项" tabindex="-1"><a class="header-anchor" href="#_4-安装依赖项"><span>4. 安装依赖项</span></a></h3><ul><li>Npm 按照构建好的依赖树结构，在 node_modules 目录中安装依赖项。</li></ul><h3 id="_5-执行生命周期脚本" tabindex="-1"><a class="header-anchor" href="#_5-执行生命周期脚本"><span>5. 执行生命周期脚本</span></a></h3><ul><li>Npm 执行相关的生命周期脚本，如 preinstall、install 和 postinstall。</li></ul><h3 id="_6-生成或更新-package-lock-json" tabindex="-1"><a class="header-anchor" href="#_6-生成或更新-package-lock-json"><span>6. 生成或更新 package-lock. Json</span></a></h3><ul><li>如果 package. Json 中的依赖项没有变化，package-lock. Json 文件保持不变。</li><li>如果 package. Json 中的依赖项发生变化，package-lock. Json 文件会被更新。</li></ul><h2 id="没有-package-lock-json-文件的情况" tabindex="-1"><a class="header-anchor" href="#没有-package-lock-json-文件的情况"><span>没有 package-lock. Json 文件的情况</span></a></h2><h3 id="_1-读取-package-json-文件" tabindex="-1"><a class="header-anchor" href="#_1-读取-package-json-文件"><span>1 . 读取 package. Json 文件</span></a></h3><ul><li>Npm 读取 package. Json 文件中的 dependencies 和 devDependencies 字段，获取所有依赖项及其版本范围。</li></ul><h3 id="_2-解析依赖树" tabindex="-1"><a class="header-anchor" href="#_2-解析依赖树"><span>2 . 解析依赖树</span></a></h3><ul><li>解析每个依赖项的版本范围，并构建一个完整的依赖树。</li><li>确定需要安装的具体依赖项版本。</li></ul><h3 id="_3-下载依赖项" tabindex="-1"><a class="header-anchor" href="#_3-下载依赖项"><span>3 . 下载依赖项</span></a></h3><ul><li>对于每个依赖项，npm 会尝试从 npm 注册表下载对应的包。</li><li>在下载之前，npm 会检查本地缓存中是否有对应版本的包。</li></ul><h3 id="_4-利用缓存" tabindex="-1"><a class="header-anchor" href="#_4-利用缓存"><span>4 . 利用缓存</span></a></h3><ul><li>如果本地缓存中有对应版本的包，npm 将直接从缓存中恢复这些包。</li><li>如果缓存中没有对应的包，npm 会从 npm 注册表下载这些包，并将其保存到本地缓存中。</li></ul><h3 id="_5-安装依赖项" tabindex="-1"><a class="header-anchor" href="#_5-安装依赖项"><span>5 . 安装依赖项</span></a></h3><ul><li>在 node_modules 目录中安装这些依赖项。</li><li>确保每个依赖项只安装一次，即使它被多个顶层依赖项共享。</li></ul><h3 id="_6-生成-package-lock-json-文件" tabindex="-1"><a class="header-anchor" href="#_6-生成-package-lock-json-文件"><span>6 . 生成 package-lock. Json 文件</span></a></h3><ul><li>安装完成后，npm 会生成一个 package-lock. Json 文件，记录所有安装的确切版本和依赖树结构。   <img src="https://coderchao.oss-cn-shanghai.aliyuncs.com/images/1724839328986.png" alt="1724839328986.png"></li></ul>',27)]))}const k=l(s,[["render",i],["__file","index.html.vue"]]),t=JSON.parse('{"path":"/article/loj8iqow/","title":"npm install 底层原理","lang":"zh-CN","frontmatter":{"title":"npm install 底层原理","createTime":"2024/11/07 14:35:04","permalink":"/article/loj8iqow/","tags":["工程化","npm"]},"headers":[{"level":2,"title":"有 package-lock. Json 文件的情况","slug":"有-package-lock-json-文件的情况","link":"#有-package-lock-json-文件的情况","children":[{"level":3,"title":"1 . 读取 package-lock. Json 文件","slug":"_1-读取-package-lock-json-文件","link":"#_1-读取-package-lock-json-文件","children":[]},{"level":3,"title":"2 . 验证一致性","slug":"_2-验证一致性","link":"#_2-验证一致性","children":[]},{"level":3,"title":"3 . 从缓存中获取依赖项","slug":"_3-从缓存中获取依赖项","link":"#_3-从缓存中获取依赖项","children":[]},{"level":3,"title":"4. 安装依赖项","slug":"_4-安装依赖项","link":"#_4-安装依赖项","children":[]},{"level":3,"title":"5. 执行生命周期脚本","slug":"_5-执行生命周期脚本","link":"#_5-执行生命周期脚本","children":[]},{"level":3,"title":"6. 生成或更新 package-lock. Json","slug":"_6-生成或更新-package-lock-json","link":"#_6-生成或更新-package-lock-json","children":[]}]},{"level":2,"title":"没有 package-lock. Json 文件的情况","slug":"没有-package-lock-json-文件的情况","link":"#没有-package-lock-json-文件的情况","children":[{"level":3,"title":"1 . 读取 package. Json 文件","slug":"_1-读取-package-json-文件","link":"#_1-读取-package-json-文件","children":[]},{"level":3,"title":"2 . 解析依赖树","slug":"_2-解析依赖树","link":"#_2-解析依赖树","children":[]},{"level":3,"title":"3 . 下载依赖项","slug":"_3-下载依赖项","link":"#_3-下载依赖项","children":[]},{"level":3,"title":"4 . 利用缓存","slug":"_4-利用缓存","link":"#_4-利用缓存","children":[]},{"level":3,"title":"5 . 安装依赖项","slug":"_5-安装依赖项","link":"#_5-安装依赖项","children":[]},{"level":3,"title":"6 . 生成 package-lock. Json 文件","slug":"_6-生成-package-lock-json-文件","link":"#_6-生成-package-lock-json-文件","children":[]}]}],"readingTime":{"minutes":2.36,"words":709},"git":{"createdTime":1730966370000,"updatedTime":1730966370000,"contributors":[{"name":"coderchao","email":"coderchao@foxmail.com","commits":1}]},"filePathRelative":"工程化/npm install 底层原理.md","categoryList":[{"id":"d994a6","sort":10004,"name":"工程化"}],"bulletin":false}');export{k as comp,t as data};
